* Protected Analog ADC with Dual Mirrored Ramp Generators

* Libraries

{ifdef foss}
.lib /foss/pdk/sky130A/libs.tech/ngspice/sky130.lib.spice {corner=tt}
{else}
.lib "models/sky130.lib.spice" {corner=tt}
{endif}
.lib adc.lib {ifdef layout layout else design}

* Inputs

vrst  rst   gnd PULSE(0   1.8 0 10p 10p 3u 260u)
vrstn rstn  gnd PULSE(1.8 0.0 0 10p 10p 3u 260u)
vclk  clk   gnd PULSE(0   1.8 0 10p 10p .5u 1u)
vdda  vdd   gnd 1.8
vrfp  gnd   vrefp 1
vrfn  vrefn gnd   1

{for p in range(pixels)}
vpix{p} pix{p} GND 0.3
{endfor}

vc0  vc0 GND PWL(0 0 67u 0 67.1u 0 131u 0 131.1u 0 195u 0 195.1u 0 259u 0 260u 0) r=0
vc1  vc1 GND PWL(0 0 67u 0 67.1u 0 131u 0 131.1u 0 195u 0 195.1u 0 259u 0 260u 0) r=0
vc2  vc2 GND PWL(0 0 67u 0 67.1u 0 131u 0 131.1u 0 195u 0 195.1u 0 259u 0 260u 0) r=0
vc3  vc3 GND PWL(0 0 67u 0 67.1u 0 131u 0 131.1u 0 195u 0 195.1u 0 259u 0 260u 0) r=0
vc4  vc4 GND PWL(0 0 67u 0 67.1u 0 131u 0 131.1u 0 195u 0 195.1u 0 259u 0 260u 0) r=0

* Analog ADC

xrmpp vrefp      vc0 vc1 vc2 vc3 vc4 rampp vdd gnd rst  ramp_generator
xrmpn vrefn vdd  vc0 vc1 vc2 vc3 vc4 rampn vdd gnd rst  ramp_generator_init_k

{for p in range(pixels)}
xcmpp{p} rampp pix{p} clk outpp{p} outnp{p} vdd gnd comparator_wrap
xcmpn{p} rampn pix{p} clk outpn{p} outnn{p} vdd gnd comparator_wrap
{endfor}

.control
{randpx0=compose randpx0 values 3e-1 7e-1}
{randpx1=compose randpx1 values 2e-1 8e-1}
{randpx2=compose randpx2 values 1e-1 9e-1}
{randpx3=compose randpx3 values 4e-1 6e-1}
{randpx4=compose randpx4 values 5e-1 5e-1}
{randvc0=compose randvc0 values 0   18e-1 18e-1     0  18e-1     0 0 18e-1}
{randvc1=compose randvc1 values 0   18e-1     0     0    0       0 0 18e-1}
{randvc2=compose randvc2 values 0   18e-1     0     0    0       0 0 18e-1}
{randvc3=compose randvc3 values 0   18e-1     0     0    0       0 0 18e-1}
{randvc4=compose randvc4 values 0   18e-1     0 18e-1    0   18e-1 0 18e-1}

let istart = 0
let istop  = length(randpx0)

set ext = ".txt"
set dlm = "_"

{ifndef plot}
shell mkdir -p {outdir=outfiles/analog}
{endif}

while istart < istop
    echo
    echo Running Sweep $&istart/$&istop
    echo

    let iseed = istart + {seed}

    {for p in range(pixels)}
    let   vact{p} = randpx{p}[istart]
    alter vpix{p} vact{p}
    {endfor}
    let index = istart*4 % length(randvc0)
    {for i in range(4)}
    let V1 = randvc{i}[index]
    let V2 = randvc{i}[index+1]
    let V3 = randvc{i}[index+2]
    let V4 = randvc{i}[index+3]
    alter @vc{i}[pwl] = [ 0 $&V1 67u $&V1 67.1u $&V2 131u $&V2 131.1u $&V3 195u $&V3 195.1u $&V4 259u $&V4 260u $&V1 ]
    {endfor}

    tran 500n 520u uic
    
    let cut-tstart = 260u
    let cut-tstop = 520u
    cutout

    {ifndef plot}
    {if pixels == 5}
    wrdata {outdir=outfiles/analog}/raw_s$&iseed$dlm$&vact0$dlm$&vact1$dlm$&vact2$dlm$&vact3$dlm$&vact4$ext -I(vdda)
    {else}
    wrdata {outdir=outfiles/analog}/raw_s$&iseed$dlm$&vact0$ext -I(vdda)
    {endif}
    {else}
    plot outpp0 outnp0
    {if pixels == 5}
    plot outpp0 outpp1 outpp2 outpp3 outpp4
    {endif}
    plot rampp rampn pix
    plot i(vdda)
    plot vc0 vc1+2 vc2+4 vc3+6 vc4+8
    {endif}

    let lin-tstart = 260u
    let lin-tstop  = 520u
    let lin-tstep  = 100n
    linearize I(vdda) ; digitized

    {ifndef plot}
    {if pixels == 5}
    wrdata {outdir=outfiles/analog}/lin_s$&iseed$dlm$&vact0$dlm$&vact1$dlm$&vact2$dlm$&vact3$dlm$&vact4$ext -I(vdda)
    {else}
    wrdata {outdir=outfiles/analog}/lin_s$&iseed$dlm$&vact0$ext -I(vdda)
    {endif}
    {else}
    ;plot i(v.xrmpp.vim) i(v.xrmpn.vim)
    ;plot (-i(vrfp)) (-i(vrfn))
    {endif}

    let istart = istart + 1
    {ifndef plot destroy all}
end
{ifndef plot exit}
.endc

.end
