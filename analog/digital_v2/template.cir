Simulation of digital counter circuit synthesized with Yosys
{default pixels   1}
{assert  pixels > 0}
{define  getbus func:name,suffix="",rng=range(8): " ".join(name+str(suffix)+"."+str(i) for i in rng)}
{define  dplot  func:vars: " ".join(var+"/2+"+str(i) for i, var in enumerate(vars.split()))}
{define  dbus   func:name,suffix="",rng=range(8): "+".join(name+str(suffix)+"."+str(i)+"/"+str(1 << (8-i)) for i in rng)}
{default outdir "outfiles"}
{default dump 0}
{default plot dump == 0}

** Libraries --------------------------------------------------

{ifxst /foss/pdk/sky130A/libs.tech/ngspice/sky130.lib.spice}
.lib "/foss/pdk/sky130A/libs.tech/ngspice/sky130.lib.spice" {corner=tt}
.include "/foss/pdk/sky130A/libs.ref/sky130_fd_sc_hs/spice/sky130_fd_sc_hs.spice"
{else}
.lib "models/sky130.lib.spice" {corner=tt}
.include cells/a211oi/sky130_fd_sc_hs__a211oi_1.spice
.include cells/a21oi/sky130_fd_sc_hs__a21oi_1.spice
.include cells/and2/sky130_fd_sc_hs__and2_1.spice
.include cells/and3/sky130_fd_sc_hs__and3_1.spice
.include cells/and4/sky130_fd_sc_hs__and4_1.spice
.include cells/clkinv/sky130_fd_sc_hs__clkinv_1.spice
.include cells/dfxtp/sky130_fd_sc_hs__dfxtp_1.spice
.include cells/inv/sky130_fd_sc_hs__inv_1.spice
.include cells/mux2i/sky130_fd_sc_hs__mux2i_1.spice
.include cells/mux2/sky130_fd_sc_hs__mux2_1.spice
.include cells/nand2b/sky130_fd_sc_hs__nand2b_1.spice
.include cells/nor2b/sky130_fd_sc_hs__nor2b_1.spice
.include cells/nor2/sky130_fd_sc_hs__nor2_1.spice
.include cells/nor3b/sky130_fd_sc_hs__nor3b_1.spice
.include cells/nor3/sky130_fd_sc_hs__nor3_1.spice
.include cells/nor4b/sky130_fd_sc_hs__nor4b_1.spice
.include cells/o21a/sky130_fd_sc_hs__o21a_1.spice
.include cells/o21bai/sky130_fd_sc_hs__o21bai_1.spice
.include cells/o21ba/sky130_fd_sc_hs__o21ba_1.spice
.include cells/or2/sky130_fd_sc_hs__or2_1.spice
.include cells/or3b/sky130_fd_sc_hs__or3b_1.spice
.include cells/xor2/sky130_fd_sc_hs__xor2_1.spice
{endif}

*.lib lib/register_array.spice    {ifdef regarry_header model else synth}
*.inc lib/negedge_detector.spice ;{ifdef edetect_header model else synth}
.lib lib/counter_half.spice      {ifdef counter_header model else synth}
.inc lib/double_rate_sampler_{version=v2}.spice

** Counter -------------------------------------------------

XCOUNTER clk rst cen {getbus("count")} overflow vss vss vdd vdd counter_half 
* cen = delayed inverted rst
xcen    rst vss vss vdd vdd cen_d sky130_fd_sc_hs__inv_1
xcen_ff clk cen_d vss vss vdd vdd cen sky130_fd_sc_hs__dfxtp_1

** Per Pixel Modules ---------------------------------------

{for p in range(1, pixels+1)}

xsample_{p} clk2 rst comp_toggl.{p} comp_toggln.{p} {getbus("count")} {getbus("pixel",p)} {getbus("pixeld",p)} vss vss vdd vdd double_rate_sampler

{endfor}

** Control Signals -----------------------------------------

* Voltage sources
.param vdd=1.8
Vdd vdd 0 {vdd}

.param vss=0
Vss vss 0 {vss}

* Clock and Reset signals (1MHz clock)
Vrst    rst     0   pulse   {vss}   {vdd}   0u      10n  10n    2u    260u
Vclk    clk     0   pulse   {vss}   {vdd}   1u      10n  10n  0.5u      1u
Vclk2   clk2    0   pulse   {vss}   {vdd}   1.25u   10n  10n 0.25u    0.5u

* Model Clocked Comparator
{for p in range(1, pixels+1)}
Vcomp{p} comp_ideal.{p} 0 pulse {vss} {vdd} 32u 5n 5n 224u 260u
Bcomp{p} comp_toggl.{p} 0 V = V(comp_ideal.{p}) > {vdd/2} ? V(clk) : {vss}     ; regular  comp out
Bcompn{p} comp_toggln.{p} 0 V = V(comp_ideal.{p}) > {vdd/2} ? {vss} : V(clk) ; inverted comp out
{endfor}

** Simulation Control --------------------------------------

.option method=Gear
.control
;set color0=white
set color1=rgb:50/50/50

{randvec_1=compose  randvec_1  values 30  90 160}
{if pixels >= 5}    
{randvec_2=compose  randvec_2  values 16  0 255}
{randvec_3=compose  randvec_3  values 128 0 255}
{randvec_4=compose  randvec_4  values 96  0 255}
{randvec_5=compose  randvec_5  values 32  0 255}
{endif}             
{if pixels >= 10}   
{randvec_6=compose  randvec_6  values 16  0 255}
{randvec_7=compose  randvec_7  values 128 0 255}
{randvec_8=compose  randvec_8  values 96  0 255}
{randvec_9=compose  randvec_9  values 32  0 255}
{randvec_10=compose randvec_10 values 32  0 255}
{endif}

let treset  = 2u
let tgap    = 2u
let period  = 1u
let digmax  = 256
let istart  = {simstart=0}
let istop   = {numsim=length(randvec_1)}
let tmax    = digmax * period + treset + tgap

set ext = ".txt"
set dlm = "_"

{if dump}
shell mkdir -p {outdir}
set wr_singlescale
set wr_vecnames
{endif}

while istart < istop
    echo
    echo Running Sweep $&istart/$&istop
    echo

    let iseed = istart + {seed=0}
    {for p in range(1, pixels+1)}
    let dvalue_{p} = randvec_{p}[istart]
    let tstart = treset + dvalue_{p} * period
    let twidth = tmax - tstart - tgap
    alter @Vcomp{p}[pulse] [ 0 1.8 $&tstart 5n 5n $&twidth $&tmax ]
    {endfor}

    ;tran 1u 520u uic
    ;tran 1u 260u uic
    tran 1u 90u uic
    
    {if plot}
    let digit_count = {dbus("count")}
    let digit_sampl = {dbus("pixel1")}
    let digit_false = {dbus("pixeld1")}

    plot title 'Current Trace' -I(vdd)
    plot title 'Digital Outputs' digit_false digit_sampl digit_count comp_ideal.1
    plot title 'Comp_D' {dplot("clk clk2 xsample_1.reset_cycle comp_toggl.1 xsample_1.comp_d")}
    {endif}

    {if dump}
    ;let cut-tstart = 260u
    ;let cut-tstop = 520u
    ;cutout

    wrdata {outdir}/sky_raw_s$&iseed{for i in range(1,pixels+1)}$dlm$&dvalue_{i}{endfor}$ext -I(vdd)

    ;let lin-tstart = 260u
    ;let lin-tstop  = 520u
    ;let lin-tstep  = 100n
    ;linearize I(vdd)

    ;wrdata {outdir}/sky_lin_s$&iseed{for i in range(1,pixels+1)}$dlm$&dvalue_{i}{endfor}$ext -I(vdd)

    {if not plot}destroy all{endif}
    {endif}

    let istart = istart + 1
end
{if not plot}
echo
echo -----------------------------------------
echo All simulations completed. 
echo Exiting...
echo -----------------------------------------
echo
exit
{endif}
.endc

.END

